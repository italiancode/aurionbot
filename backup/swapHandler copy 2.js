const { swapTokens } = require("../solana/spiderswap/swap");
const { getWallet } = require("../solana/wallet/storage");
const TokenDetailsCache = require("../solana/SolanaTokenCache");
const { getSwapQuote } = require("../solana/spiderswap/quote");

const tokenCache = new TokenDetailsCache();
const swapSessions = {};

// Enhanced token list with icons
const TOKENS = {
  SOL: {
    address: "So11111111111111111111111111111111111111112",
    symbol: "SOL",
    name: "Solana",
    icon: "‚òÄÔ∏è"
  },
  USDC: {
    address: "EPjFWdd5AufqSSqeM2qN1xzybapC8G4wEGGkZwyTDt1v",
    symbol: "USDC",
    name: "USD Coin",
    icon: "üíµ"
  },
  USDT: {
    address: "Es9vMFrzaCERmJfrF4H2FYD4KCoNkY11McCe8BenwNYB",
    symbol: "USDT",
    name: "Tether",
    icon: "üíö"
  }
};

// Main entry point with enhanced welcome message
function initSwapFlow(bot, msg) {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || msg.chat.id.toString();
  
  const sessionKey = userId;
  const chatKey = msg.chat.id.toString();
  
  const sessionData = {
    fromToken: null,
    toToken: null,
    amount: null,
    messageId: null,
    chatId: chatId,
    quote: null
  };
  
  swapSessions[sessionKey] = sessionData;
  if (sessionKey !== chatKey) {
    swapSessions[chatKey] = sessionData;
  }
  
  showWelcomeMessage(bot, chatId, sessionKey);
}

async function showWelcomeMessage(bot, chatId, userId) {
  const welcomeMessage = 
    `üöÄ *Welcome to SpiderSwap*\n\n` +
    `‚ö° *Lightning Fast Token Swaps*\n` +
    `üîí *Secure & Decentralized*\n` +
    `üíé *Best Rates Guaranteed*\n\n` +
    `Ready to swap your tokens? Let's get started! üëá`;

  const keyboard = {
    inline_keyboard: [
      [
        { text: "üîÑ Start New Swap", callback_data: "swap_start" }
      ],
      [
        { text: "üìä View Portfolio", callback_data: "view_portfolio" },
        { text: "‚ÑπÔ∏è Help", callback_data: "swap_help" }
      ]
    ]
  };

  bot.sendMessage(chatId, welcomeMessage, {
    reply_markup: keyboard,
    parse_mode: "Markdown"
  }).then(msg => {
    swapSessions[userId].messageId = msg.message_id;
  });
}

async function showMainSwapMenu(bot, chatId, userId, editMessageId = null) {
  const session = swapSessions[userId];
  
  // Get token details for display
  const fromTokenInfo = session.fromToken ? await getTokenDisplayInfo(session.fromToken) : null;
  const toTokenInfo = session.toToken ? await getTokenDisplayInfo(session.toToken) : null;
  
  // Progress indicators
  const step1 = session.fromToken ? "‚úÖ" : "1Ô∏è‚É£";
  const step2 = session.toToken ? "‚úÖ" : "2Ô∏è‚É£";
  const step3 = session.amount ? "‚úÖ" : "3Ô∏è‚É£";
  
  const message = 
    `üîÑ *Token Swap Configuration*\n\n` +
    `‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n` +
    `‚îÇ ${step1} **FROM TOKEN**\n` +
    `‚îÇ ${fromTokenInfo ? `${fromTokenInfo.icon} ${fromTokenInfo.symbol} (${fromTokenInfo.name})` : "‚ùå Select token to swap from"}\n` +
    `‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n` +
    `‚îÇ ${step2} **TO TOKEN**\n` +
    `‚îÇ ${toTokenInfo ? `${toTokenInfo.icon} ${toTokenInfo.symbol} (${toTokenInfo.name})` : "‚ùå Select token to receive"}\n` +
    `‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n` +
    `‚îÇ ${step3} **AMOUNT**\n` +
    `‚îÇ ${session.amount ? `üí∞ ${formatNumber(session.amount)} ${fromTokenInfo?.symbol || ""}` : "‚ùå Enter swap amount"}\n` +
    `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n` +
    `${getProgressStatus(session)}`;

  const keyboard = createMainMenuKeyboard(session);

  if (editMessageId) {
    bot.editMessageText(message, {
      chat_id: chatId,
      message_id: editMessageId,
      reply_markup: keyboard,
      parse_mode: "Markdown"
    });
  } else {
    bot.sendMessage(chatId, message, {
      reply_markup: keyboard,
      parse_mode: "Markdown"
    }).then(msg => {
      swapSessions[userId].messageId = msg.message_id;
    });
  }
}

function createMainMenuKeyboard(session) {
  const allSet = session.fromToken && session.toToken && session.amount;
  
  return {
    inline_keyboard: [
      [
        { text: `${session.fromToken ? "üîÑ" : "üì§"} From Token`, callback_data: "swap_select_from" },
        { text: `${session.toToken ? "üîÑ" : "üì•"} To Token`, callback_data: "swap_select_to" }
      ],
      [
        { text: `${session.amount ? "‚úèÔ∏è" : "üí∞"} Set Amount`, callback_data: "swap_set_amount" }
      ],
      ...(session.fromToken && session.toToken ? [
        [{ text: "üîÑ Swap Tokens", callback_data: "swap_reverse" }]
      ] : []),
      ...(allSet ? [
        [{ text: "üìä Get Quote & Preview", callback_data: "swap_get_quote" }]
      ] : []),
      [
        { text: "üè† Main Menu", callback_data: "swap_main" },
        { text: "‚ùå Cancel", callback_data: "swap_cancel" }
      ]
    ]
  };
}

function getProgressStatus(session) {
  if (session.fromToken && session.toToken && session.amount) {
    return "üéØ *Ready to get quote!* Tap 'Get Quote & Preview' to continue.";
  } else if (session.fromToken && session.toToken) {
    return "üí∞ *Almost there!* Please set the amount to swap.";
  } else if (session.fromToken || session.toToken) {
    return "‚ö° *Good start!* Please complete the remaining steps.";
  } else {
    return "üöÄ *Let's begin!* Start by selecting your tokens.";
  }
}

async function handleSwapCallbacks(bot, callbackQuery) {
  const data = callbackQuery.data;
  const msg = callbackQuery.message;
  const chatId = msg.chat.id;
  const fromId = callbackQuery.from.id.toString();
  const chatIdStr = chatId.toString();
  
  let userId = fromId;
  let session = swapSessions[fromId];
  
  if (!session && swapSessions[chatIdStr]) {
    userId = chatIdStr;
    session = swapSessions[chatIdStr];
  }
  
  if (!session && data !== "swap_start") {
    bot.answerCallbackQuery(callbackQuery.id, { 
      text: "‚ö†Ô∏è Session expired. Starting fresh!", 
      show_alert: false 
    });
    return initSwapFlow(bot, { chat: { id: chatId }, from: { id: fromId } });
  }

  bot.answerCallbackQuery(callbackQuery.id);

  switch (data) {
    case "swap_start":
      if (!session) {
        const sessionData = {
          fromToken: null,
          toToken: null,
          amount: null,
          messageId: null,
          chatId: chatId,
          quote: null
        };
        swapSessions[fromId] = sessionData;
        if (fromId !== chatIdStr) {
          swapSessions[chatIdStr] = sessionData;
        }
      }
      showMainSwapMenu(bot, chatId, fromId, msg.message_id);
      break;
    case "swap_main":
      showWelcomeMessage(bot, chatId, userId);
      break;
    case "swap_select_from":
      showTokenSelection(bot, chatId, userId, "from");
      break;
    case "swap_select_to":
      showTokenSelection(bot, chatId, userId, "to");
      break;
    case "swap_set_amount":
      promptForAmount(bot, chatId, userId);
      break;
    case "swap_reverse":
      reverseTokens(bot, chatId, userId);
      break;
    case "swap_get_quote":
      fetchAndShowQuote(bot, chatId, userId);
      break;
    case "swap_execute":
      executeSwap(bot, callbackQuery);
      break;
    case "swap_cancel":
      cancelSwap(bot, chatId, userId);
      break;
    case "swap_back":
      showMainSwapMenu(bot, chatId, userId, swapSessions[userId].messageId);
      break;
    case "swap_help":
      showHelpMessage(bot, chatId, userId);
      break;
    default:
      if (data.startsWith("swap_from_")) {
        swapSessions[userId].fromToken = data.replace("swap_from_", "");
        showMainSwapMenu(bot, chatId, userId, swapSessions[userId].messageId);
      } else if (data.startsWith("swap_to_")) {
        swapSessions[userId].toToken = data.replace("swap_to_", "");
        showMainSwapMenu(bot, chatId, userId, swapSessions[userId].messageId);
      }
  }
}

function showTokenSelection(bot, chatId, userId, type) {
  const isFrom = type === "from";
  const prefix = isFrom ? "swap_from_" : "swap_to_";
  const emoji = isFrom ? "üì§" : "üì•";
  
  const message = 
    `${emoji} *Select ${type.toUpperCase()} Token*\n\n` +
    `Choose from popular tokens or enter a custom address:`;

  const keyboard = {
    inline_keyboard: [
      [
        { text: `${TOKENS.SOL.icon} ${TOKENS.SOL.symbol}`, callback_data: `${prefix}${TOKENS.SOL.address}` },
        { text: `${TOKENS.USDC.icon} ${TOKENS.USDC.symbol}`, callback_data: `${prefix}${TOKENS.USDC.address}` }
      ],
      [
        { text: `${TOKENS.USDT.icon} ${TOKENS.USDT.symbol}`, callback_data: `${prefix}${TOKENS.USDT.address}` }
      ],
      [
        { text: "üîç Custom Token", callback_data: `swap_custom_${type}` }
      ],
      [
        { text: "‚Ü©Ô∏è Back", callback_data: "swap_back" },
        { text: "‚ùå Cancel", callback_data: "swap_cancel" }
      ]
    ]
  };

  bot.editMessageText(message, {
    chat_id: chatId,
    message_id: swapSessions[userId].messageId,
    reply_markup: keyboard,
    parse_mode: "Markdown"
  });
}

async function promptForAmount(bot, chatId, userId) {
  const session = swapSessions[userId];
  
  if (!session.fromToken) {
    return bot.answerCallbackQuery(callbackQuery.id, { 
      text: "‚ö†Ô∏è Please select FROM token first", 
      show_alert: true 
    });
  }

  const tokenInfo = await getTokenDisplayInfo(session.fromToken);
  
  const message = 
    `üí∞ *Enter Swap Amount*\n\n` +
    `${tokenInfo.icon} **${tokenInfo.symbol}** (${tokenInfo.name})\n\n` +
    `üí° *Examples:*\n` +
    `‚Ä¢ \`0.5\` - Half token\n` +
    `‚Ä¢ \`10\` - Ten tokens\n` +
    `‚Ä¢ \`100.25\` - With decimals\n\n` +
    `Please enter the amount you want to swap:`;

  bot.editMessageText(message, {
    chat_id: chatId,
    message_id: session.messageId,
    reply_markup: {
      inline_keyboard: [
        [
          { text: "‚Ü©Ô∏è Back", callback_data: "swap_back" },
          { text: "‚ùå Cancel", callback_data: "swap_cancel" }
        ]
      ]
    },
    parse_mode: "Markdown"
  });
  
  session.waitingForAmount = true;
}

function reverseTokens(bot, chatId, userId) {
  const session = swapSessions[userId];
  if (session.fromToken && session.toToken) {
    const temp = session.fromToken;
    session.fromToken = session.toToken;
    session.toToken = temp;
    session.amount = null; // Reset amount since we switched tokens
    
    bot.answerCallbackQuery(callbackQuery.id, { 
      text: "üîÑ Tokens swapped!", 
      show_alert: false 
    });
  }
  showMainSwapMenu(bot, chatId, userId, session.messageId);
}

async function fetchAndShowQuote(bot, chatId, userId) {
  const session = swapSessions[userId];
  const { fromToken, toToken, amount } = session;

  try {
    const loadingMsg = await bot.editMessageText(
      "‚è≥ *Fetching best quote...*\n\n" +
      "üîç Scanning DEX pools\n" +
      "üìä Calculating rates\n" +
      "‚ö° Finding optimal path",
      {
        chat_id: chatId,
        message_id: session.messageId,
        parse_mode: "Markdown"
      }
    );

    const quote = await getSwapQuote(fromToken, toToken, amount, 100);
    
    if (!quote.success) {
      throw new Error(quote.error || "Failed to get quote");
    }

    const fromTokenInfo = await getTokenDisplayInfo(fromToken);
    const toTokenInfo = await getTokenDisplayInfo(toToken);
    const priceImpact = parseFloat(quote.priceImpact).toFixed(2);
    const rate = (parseFloat(quote.toAmount) / parseFloat(amount)).toFixed(6);

    const message = 
      `üìä *Swap Quote Preview*\n\n` +
      `‚îå‚îÄ **SWAP DETAILS** ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê\n` +
      `‚îÇ üì§ **From:** ${formatNumber(amount)} ${fromTokenInfo.symbol}\n` +
      `‚îÇ üì• **To:** ~${formatNumber(quote.toAmount)} ${toTokenInfo.symbol}\n` +
      `‚îÇ üõ°Ô∏è **Min Receive:** ${formatNumber(quote.minimumReceived)} ${toTokenInfo.symbol}\n` +
      `‚îú‚îÄ **RATE INFO** ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§\n` +
      `‚îÇ üìà **Rate:** 1 ${fromTokenInfo.symbol} = ${rate} ${toTokenInfo.symbol}\n` +
      `‚îÇ üìä **Impact:** ${priceImpact}%\n` +
      `‚îÇ ‚ö° **Slippage:** 1.0%\n` +
      `‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò\n\n` +
      `${getPriceImpactWarning(priceImpact)}`;

    const keyboard = {
      inline_keyboard: [
        [
          { text: "‚úÖ Confirm Swap", callback_data: "swap_execute" }
        ],
        [
          { text: "üîÑ Change From", callback_data: "swap_select_from" },
          { text: "üîÑ Change To", callback_data: "swap_select_to" }
        ],
        [
          { text: "‚úèÔ∏è Change Amount", callback_data: "swap_set_amount" }
        ],
        [
          { text: "‚Ü©Ô∏è Back", callback_data: "swap_back" },
          { text: "‚ùå Cancel", callback_data: "swap_cancel" }
        ]
      ]
    };

    await bot.editMessageText(message, {
      chat_id: chatId,
      message_id: loadingMsg.message_id,
      reply_markup: keyboard,
      parse_mode: "Markdown"
    });

    session.quote = quote;
  } catch (error) {
    bot.editMessageText(
      `‚ùå *Quote Failed*\n\n` +
      `üö´ **Error:** ${error.message}\n\n` +
      `üí° **Try:**\n` +
      `‚Ä¢ Different amount\n` +
      `‚Ä¢ Different token pair\n` +
      `‚Ä¢ Check network status`,
      {
        chat_id: chatId,
        message_id: session.messageId,
        reply_markup: {
          inline_keyboard: [
            [
              { text: "üîÑ Retry", callback_data: "swap_get_quote" },
              { text: "‚Ü©Ô∏è Back", callback_data: "swap_back" }
            ]
          ]
        },
        parse_mode: "Markdown"
      }
    );
  }
}

function getPriceImpactWarning(priceImpact) {
  const impact = parseFloat(priceImpact);
  if (impact > 5) {
    return "‚ö†Ô∏è **HIGH PRICE IMPACT** - Consider smaller amount";
  } else if (impact > 2) {
    return "‚ö° **Moderate impact** - Review before confirming";
  } else {
    return "‚úÖ **Low impact** - Good rate!";
  }
}

async function executeSwap(bot, callbackQuery) {
  const msg = callbackQuery.message;
  const chatId = msg.chat.id;
  const userId = callbackQuery.from.id.toString();
  const session = swapSessions[userId];

  try {
    // Animated execution messages
    const steps = [
      "üîê Preparing transaction...",
      "üìù Signing transaction...",
      "üöÄ Broadcasting to network...",
      "‚è≥ Confirming swap..."
    ];

    for (let i = 0; i < steps.length; i++) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      await bot.editMessageText(
        `‚ö° *Executing Swap*\n\n${steps[i]}\n\n` +
        `${"‚ñì".repeat(i + 1)}${"‚ñë".repeat(3 - i)} ${Math.round((i + 1) * 25)}%`,
        {
          chat_id: chatId,
          message_id: session.messageId,
          parse_mode: "Markdown"
        }
      );
    }

    const tx = await swapTokens(
      userId,
      session.fromToken,
      session.toToken,
      session.amount
    );

    const fromTokenInfo = await getTokenDisplayInfo(session.fromToken);
    const toTokenInfo = await getTokenDisplayInfo(session.toToken);

    await bot.editMessageText(
      `üéâ *Swap Successful!*\n\n` +
      `‚úÖ **Transaction Completed**\n\n` +
      `üì§ **Swapped:** ${formatNumber(session.amount)} ${fromTokenInfo.symbol}\n` +
      `üì• **Received:** ~${formatNumber(session.quote.toAmount)} ${toTokenInfo.symbol}\n\n` +
      `üîó **Transaction Hash:**\n\`${tx}\`\n\n` +
      `üîç [View on Solscan](https://solscan.io/tx/${tx})`,
      {
        chat_id: chatId,
        message_id: session.messageId,
        reply_markup: {
          inline_keyboard: [
            [
              { text: "üîÑ New Swap", callback_data: "swap_start" },
              { text: "üìä Portfolio", callback_data: "view_portfolio" }
            ],
            [
              { text: "üè† Main Menu", callback_data: "swap_main" }
            ]
          ]
        },
        parse_mode: "Markdown"
      }
    );
  } catch (error) {
    await bot.editMessageText(
      `‚ùå *Swap Failed*\n\n` +
      `üö´ **Error:** ${error.message}\n\n` +
      `üí° **Possible Solutions:**\n` +
      `‚Ä¢ Check wallet balance\n` +
      `‚Ä¢ Try smaller amount\n` +
      `‚Ä¢ Wait for network congestion to clear\n` +
      `‚Ä¢ Contact support if issue persists`,
      {
        chat_id: chatId,
        message_id: session.messageId,
        reply_markup: {
          inline_keyboard: [
            [
              { text: "üîÑ Try Again", callback_data: "swap_back" },
              { text: "üè† Main Menu", callback_data: "swap_main" }
            ]
          ]
        },
        parse_mode: "Markdown"
      }
    );
  } finally {
    // Clean up session
    setTimeout(() => {
      delete swapSessions[userId];
      const chatIdStr = chatId.toString();
      if (userId !== chatIdStr) {
        delete swapSessions[chatIdStr];
      }
    }, 5000); // Keep session for 5 seconds for user to see result
  }
}

function cancelSwap(bot, chatId, userId) {
  const session = swapSessions[userId];
  delete swapSessions[userId];
  const chatIdStr = chatId.toString();
  if (userId !== chatIdStr) {
    delete swapSessions[chatIdStr];
  }
  
  bot.editMessageText(
    `‚ùå *Swap Cancelled*\n\n` +
    `Your swap has been cancelled safely.\n` +
    `No transactions were executed.`,
    {
      chat_id: chatId,
      message_id: session?.messageId,
      reply_markup: {
        inline_keyboard: [
          [
            { text: "üîÑ New Swap", callback_data: "swap_start" },
            { text: "üè† Main Menu", callback_data: "swap_main" }
          ]
        ]
      },
      parse_mode: "Markdown"
    }
  );
}

function showHelpMessage(bot, chatId, userId) {
  const helpMessage = 
    `‚ÑπÔ∏è *SpiderSwap Help*\n\n` +
    `**How to Swap:**\n` +
    `1Ô∏è‚É£ Select FROM token (what you want to swap)\n` +
    `2Ô∏è‚É£ Select TO token (what you want to receive)\n` +
    `3Ô∏è‚É£ Enter the amount to swap\n` +
    `4Ô∏è‚É£ Review the quote and confirm\n\n` +
    `**Features:**\n` +
    `üîÑ Reverse swap direction\n` +
    `üìä Real-time quotes\n` +
    `üõ°Ô∏è Slippage protection\n` +
    `‚ö° Fast execution\n\n` +
    `**Need Help?**\n` +
    `Contact our support team!`;

  bot.editMessageText(helpMessage, {
    chat_id: chatId,
    message_id: swapSessions[userId]?.messageId,
    reply_markup: {
      inline_keyboard: [
        [
          { text: "üîÑ Start Swap", callback_data: "swap_start" },
          { text: "üè† Main Menu", callback_data: "swap_main" }
        ]
      ]
    },
    parse_mode: "Markdown"
  });
}

// Helper functions
async function getTokenDisplayInfo(tokenAddress) {
  // Check if it's a predefined token first
  for (const [key, token] of Object.entries(TOKENS)) {
    if (token.address === tokenAddress) {
      return token;
    }
  }
  
  // Try to get from cache
  try {
    const details = await tokenCache.getTokenDetails(tokenAddress);
    return {
      symbol: details.symbol || "UNKNOWN",
      name: details.name || "Custom Token",
      icon: "ü™ô",
      address: tokenAddress
    };
  } catch {
    return {
      symbol: "CUSTOM",
      name: "Custom Token",
      icon: "ü™ô",
      address: tokenAddress
    };
  }
}

async function getTokenSymbol(tokenMint) {
  const info = await getTokenDisplayInfo(tokenMint);
  return info.symbol;
}

function formatNumber(num) {
  const n = parseFloat(num);
  if (n < 0.01) return n.toFixed(6);
  if (n < 1) return n.toFixed(4);
  if (n < 1000) return n.toFixed(2);
  if (n < 1000000) return (n / 1000).toFixed(1) + "K";
  return (n / 1000000).toFixed(1) + "M";
}

async function processMessageInput(bot, msg) {
  const chatId = msg.chat.id;
  const fromId = msg.from?.id.toString();
  const chatIdStr = chatId.toString();
  
  let userId = fromId || chatIdStr;
  let session = fromId ? swapSessions[fromId] : null;
  
  if (!session && swapSessions[chatIdStr]) {
    userId = chatIdStr;
    session = swapSessions[chatIdStr];
  }
  
  if (!session) return false;
  
  if (session.waitingForAmount) {
    const amount = parseFloat(msg.text);
    if (!isNaN(amount) && amount > 0) {
      session.amount = amount;
      session.waitingForAmount = false;
      
      // Delete the user's message for cleaner UI
      try {
        await bot.deleteMessage(chatId, msg.message_id);
      } catch (e) {
        // Ignore deletion errors
      }
      
      showMainSwapMenu(bot, chatId, userId, session.messageId);
      return true;
    } else {
      const errorMsg = await bot.sendMessage(chatId, 
        `‚ùå *Invalid Amount*\n\n` +
        `Please enter a valid number greater than 0.\n\n` +
        `**Examples:** \`0.5\`, \`10\`, \`100.25\``, {
        parse_mode: "Markdown"
      });
      
      // Auto-delete error message after 3 seconds
      setTimeout(() => {
        bot.deleteMessage(chatId, errorMsg.message_id).catch(() => {});
        bot.deleteMessage(chatId, msg.message_id).catch(() => {});
      }, 3000);
      
      return true;
    }
  }
  
  return false;
}

module.exports = {
  initSwapFlow,
  handleSwapCallbacks,
  processMessageInput
};